\chapter{Praca własna}
Proces twórczy został podzielony na dwa główne etapy: projektowanie i~implementację. Ponieważ tworzenie gry wymaga przygotowania oraz doboru odpowiedniego środowiska, etapy te zostały poprzedzone analizą problemu oraz burzą mózgów na której zarysowały się wstępne wymagania funkcjonalne. Zdefiniowane zostały również główne wymagania pozafunkcjonalne, takie jak docelowa platforma obsługująca grę. W celu zapewnienia spójnej wizji gry wśród członków zespołu, postanowiono skonstruować dokument, zawierający opis wszystkich decyzji podjętych podczas tworzenia projektu oraz wyjaśnienia dotyczące wszystkich wymagań funkcjonalnych oraz pozafunkcjonalnych -- Game Design Document (GDD), stanowiący jednocześnie załącznik~1 do niniejszej pracy.  Pomysły zebrane podczas burzy mózgów zostały poddane wnikliwej analizie, co pozwoliło na stworzenie ogólna wersji projektu. 

\section{Projektowanie}
Projektowanie jest bardzo ważnym etapem prac nad każdym projektem informatycznym. Pozwala uspójnić wizję gry w~zespole oraz zdefiniować zadania, które będą wykonywane podczas implementacji. Dlatego dobrze, gdy na tym etapie pracy w proces twórczy zaangażowany jest każdy członek zespołu. 

Istotnym elementem tworzenia projektu gry jest wnikliwa analiza wymagań funkcjonalnych oraz uszeregowanie ich według wagi. Każdy z członków zespołu posiadał własną wizję gry, dlatego nie udało się osiągnąć spójnego uszeregowania wymagań. Połączenie wizji wszystkich twórców zaowocowało spójnym projektem, opisanym w~załączniku~1 -- GDD. 

Aby zapewnić, że projekt będzie spójny, konieczne jest stworzenie dokumentów projektowych. Powstrzymuje to programistów przed puszczaniem wodzy fantazji i~tworzeniem funkcjonalności niezgodnych z projektem. 

Na tym etapie przydatna okazała się nie tylko teoretyczna wiedza na temat tworzenia zaawansowanych projektów informatycznych, ale przede wszystkim doświadczenia innych twórców gier, które zespół poznał przy okazji udziału w~konferencjach takich jak Zjazd Twórców Gier (ZTG) czy World of Gamedev Knowledge (WGK). Zdobyto wiedzę potrzebną między innymi do stworzenia poziomów ciekawych dla graczy, wyboru funkcjonalności nie wymagających skomplikowanych i~często zawiłych implementacyjnie elementów (co często powoduje błędy i~trudności w~dalszym rozwoju projektu), jednocześnie będących skomplikowanymi z~punktu widzenia gracza. 

Dobrą praktyką przy tworzeniu gry jest również częste testowanie graficznego interfejsu użytkownika, jego czytelności i~łatwości użycia kluczowych funkcji w~ferworze walki. Pozwala to zaprojektować interfejs przyciągający wzrok oraz funkcjonalny. Projektując HUD [ang. \emph{Head-Up Display}], a~więc wszystkie istotne w~trakcie rozgrywki wskaźniki, mapkę, poziom życia; postanowiono rozmieścić interesujące dla gracza informacje analogicznie do popularnych gier z~gatunku strzelanek. Jest to atrakcyjne dla graczy, ponieważ nie muszą zmieniać swoich przyzwyczajeń by sprawdzić poziom życia. 

Jednak projektowanie to nie tylko uspójnienie rozgrywki, ale również specyfikacja dotycząca środowiska, w~którym gra powstanie. W tym celu należało wybrać odpowiednie narzędzia, co zostało opisane w~Rozdziale 3: Przegląd narzędzi. 

\subsection{Projekt silnika graficznego}

W ramach pracy jako pierwsze przetestowano podejście z~tworzeniem własnego silnika graficznego w~języku C++. Jak zostało wspomniane w~poprzednim rozdziale, tworzenie tego rodzaju oprogramowania wymaga pewnej określonej wiedzy dotyczącej zarówno architektury silników~graficznych i~inżynierii oprogramowania, jak i~grafiki komputerowej oraz Microsoft DirectX API. Jako że wiedza teoretyczna wraz z podstawowymi pojęciami zostały zarysowane w rozdziale 2., tutaj opisane zostaną kwestie dotyczące architektury silnika oraz usprawnień, które mogłyby zostać wprowadzone w~przyszłości.\\

W silniku graficznym można zasadniczo wydzielić 3 podstawowe składowe:
\begin{itemize}
\item renderer - przeprowadza proces renderingu, tj. generowania grafiki,
\item menedżer obiektów - zawiera listę obiektów i/lub listę ich grup,
\item menedżer zasobów - odpowiada za alokację i zwalnianie zasobów takich jak tekstury, dźwięki itp.
\end{itemize}

W ramach menedżera obiektów zastosowano wzorzec kompozyt ze względu na jego idealne dopasowanie do problemu.
Jak widać każda z~tych składowych może stanowić pewną jednostkę (ang. \emph{entity}) budującą system - w~tym wypadku system graficzny (wyróżnia się również na przykład systemy fizyki). Jednostki można również podzielić na mniejsze komponenty, które można dynamicznie dodawać i~usuwać w trakcie działania - podejście takie zgodne jest wzorcem \emph{Entity-Component-System}. Jak zauważono podczas testowania opisywanego oprogramowania, poza wygodą oraz nowymi możliwościami rozwoju wykorzystanie dynamicznych komponentów wprowadza także narzut czasowy ze względu na wykorzystanie metod wirtualnych oraz nieoptymalne wykorzystanie pamięci podręcznej procesora. W~tym wypadku możliwym usprawnieniem mogłoby być budowanie aplikacji z~komponentów w~edytorze, a~następnie generowanie "stałych" klas i~kompilowanie zmodyfikowanego w~ten sposób kodu do pliku wykonywalnego, który mógłby być dystrybuowany jako gotowa aplikacja.\\
Nieoptymalne wykorzystanie pamięci podręcznej procesora dotyczy nie tylko wykorzystania komponentów, gdyż jest wąskim gardłem większości zarówno amatorskich jak i~profesjonalnych silników graficznych. W~celu zniwelowania tego problemu można utworzyć pewien stały obszar pamięci (w~języku C++ w~wersji 11. w tym celu wykorzystać można operator \emph{placement new}) i~utworzyć pulę obiektów, w~ramach której mogłyby one być używane ponownie bez konieczności zwalniania zajmowanej przez nie pamięci.\\
Ostatnim usprawnieniem, które można byłoby wprowadzić celem zwiększenia efektywności procesu renderingu jest wielowątkowość, która jednak wymagałaby wprowadzenia synchronizacji między wątkami aplikacji (np. zamki) oraz użycia metod DirectX obsługujących wielowątkowość (np. operować na opóźnionym kontekście urządzenia). Jej użycie utrudniałoby też skuteczną naprawę błędów ze względu na brak możliwości odpluskwiania kodu w środowisku Microsoft Visual Studio, w którym tworzone było to oprogramowanie.\\
Dla silnika została napisana i wygenerowana z wykorzystaniem aplikacji Doxygen dokumentacja, jednak ze względu na swoją objętość (150 stron) nie została tutaj załączona.
% dodawać wykaz klas, przestrzeni nazw i kod źródłowy + dokumentację w pdf?
% dodać do literatury tekst o EntityComponentSystem + o deferred shading i tutoriale z animacji

\subsection{Modele 3D i animacje}



\subsection{Projekt poziomu}

\section{Implementacja}

\subsection{Wykorzystanie technologii DirectX 11 w~UDK}
% opisać czym jest bokeh i bokeh depth of field, sss i deferred rendering (wszystko z punktu widzenia UDK)

\subsection{Zarządzanie projektem}
W~celu sprawnej organizacji pracy w~zespole wykorzystano metody zarządzania projektami. Uspójnienie projektu gry podczas fazy projektowania pozwoliło na zdefiniowanie i~wyspecyfikowanie zadań, realizowanych podczas implementacji. Znając liczbę zadań, można było podzielić projekt na kolejne przyrosty. Projekt miał być realizowany z~wykorzystaniem metod zwinnych. Trudnością w~wykorzystaniu typowej zwinnej metody, takiej jak programowanie ekstremalne czy Scrum okazał się charakter projektu, będącego pracą dyplomową. Z~tego względu narzucony został ostateczny termin ukończenia produktu. Jest to sprzeczne z manifestem zwinności, dlatego zdecydowano się na inne rozwiązanie.

Początkowo użyto modelu kaskadowego. Jego zaletą jest sekwencyjność, pozwalająca oddzielić procesy analizy problemu, projektowania, implementacji oraz testowania i~późniejszego utrzymania projektu. Metoda Waterfall, wykorzystująca ten model, nie jest jednak pozbawiona wad. 
Dotyczą one głównie dużych projektów, a~więc nie miały miejsca w~przypadku oprogramowania tworzonego w~czteroosobowym zespole programistów. Korzystając z~tej metody oszczędza się czas na planowaniu, faza ta zajmuje zaledwie 25\% czasu pracy nad projektem. Rezultat końcowy zostaje ustalony jeszcze przed rozpoczęciem implementacji, podobnie jak poszczególne przyrosty implementacji. Każdy przyrost miał trwać 2 tygodnie i~zawierał określone zadania. Rezultatem końcowym był produkt posiadający wartość biznesową, w~tym przypadku - w~pełni działająca gra. Co istotne, wartość biznesową produkt miał zyskać dopiero w~przedostatnim przyroście.

W~niedługim czasie po zaplanowaniu prac nad projektem okazało się, że metoda ta nie jest wystarczająca, zaczęło się pojawiać opóźnienie w~pracach, które mogło spowodować pogorszenie jakości produktu. Zdecydowano się więc skorzystać z~metod zwinnych. Metodyki Agile charakteryzują się stałą jakością, a~sterowane są zakresem. W~omówionej wcześniej metodzie Waterfall zakres był stały, zmieniała się jedynie jakość, a~chęć utrzymania wysokiej jakości powodowała opóźnienie względem planu. 

Ostatecznie zastosowano metodykę zwinną zbliżoną do metody Scrum. Zadania podzielono na część dotyczącą rozpoznania danego zagadnienia i~część implementacyjną. Realizowane były tygodniowe sprinty (przyrosty). Na koniec każdego z~nich otrzymywany był prototyp posiadający pewną funkcjonalność. Ze względu na wcześniejszy nieudany eksperyment z~metodą Waterfall wartość biznesową projekt zyskał dopiero po kliku przyrostach. Oznacza to, że pierwsze efekty nie były satysfakcjonujące, jednak prezentowały postęp prac. Każdy sprint rozpoczynał się spotkaniem zespołu, na którym omówiono pozostałe zadania oraz zaplanowano jakie funkcjonalności będą implementowane w~kolejnym przyroście. W~efekcie udało się zachować jakość wykonania oraz zakończyć prace przed upływem niezmiennego terminu ukończenia, modyfikując nieznacznie zakres dostępnych funkcjonalności.